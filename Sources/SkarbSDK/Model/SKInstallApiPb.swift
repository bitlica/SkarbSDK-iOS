// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app/install/installapi/api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Installapi_DeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: Auth_Auth {
    get {return _storage._auth ?? Auth_Auth()}
    set {_uniqueStorage()._auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return _storage._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {_uniqueStorage()._auth = nil}

  /// random unique value, e.g. timestamp+rand(int64)
  var installID: String {
    get {return _storage._installID}
    set {_uniqueStorage()._installID = newValue}
  }

  var idfa: String {
    get {return _storage._idfa}
    set {_uniqueStorage()._idfa = newValue}
  }

  var idfv: String {
    get {return _storage._idfv}
    set {_uniqueStorage()._idfv = newValue}
  }

  var bundleVer: String {
    get {return _storage._bundleVer}
    set {_uniqueStorage()._bundleVer = newValue}
  }

  var locale: String {
    get {return _storage._locale}
    set {_uniqueStorage()._locale = newValue}
  }

  var device: String {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  var osVer: String {
    get {return _storage._osVer}
    set {_uniqueStorage()._osVer = newValue}
  }

  var receiptURL: String {
    get {return _storage._receiptURL}
    set {_uniqueStorage()._receiptURL = newValue}
  }

  var receiptLen: String {
    get {return _storage._receiptLen}
    set {_uniqueStorage()._receiptLen = newValue}
  }

  var docDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._docDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._docDate = newValue}
  }
  /// Returns true if `docDate` has been explicitly set.
  var hasDocDate: Bool {return _storage._docDate != nil}
  /// Clears the value of `docDate`. Subsequent reads from it will return its default value.
  mutating func clearDocDate() {_uniqueStorage()._docDate = nil}

  var buildDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._buildDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._buildDate = newValue}
  }
  /// Returns true if `buildDate` has been explicitly set.
  var hasBuildDate: Bool {return _storage._buildDate != nil}
  /// Clears the value of `buildDate`. Subsequent reads from it will return its default value.
  mutating func clearBuildDate() {_uniqueStorage()._buildDate = nil}

  var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  var region: String {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  var sdkInitDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._sdkInitDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._sdkInitDate = newValue}
  }
  /// Returns true if `sdkInitDate` has been explicitly set.
  var hasSdkInitDate: Bool {return _storage._sdkInitDate != nil}
  /// Clears the value of `sdkInitDate`. Subsequent reads from it will return its default value.
  mutating func clearSdkInitDate() {_uniqueStorage()._sdkInitDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Installapi_AttribRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: Auth_Auth {
    get {return _auth ?? Auth_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var installID: String = String()

  var broker: String = String()

  /// json data
  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: Auth_Auth? = nil
}

struct Installapi_TestRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: Auth_Auth {
    get {return _auth ?? Auth_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var installID: String = String()

  var name: String = String()

  var group: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: Auth_Auth? = nil
}

struct Installapi_EraseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: Auth_Auth {
    get {return _auth ?? Auth_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var installID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: Auth_Auth? = nil
}

struct Installapi_IDFARequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: Auth_Auth {
    get {return _auth ?? Auth_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var installID: String = String()

  var idfa: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: Auth_Auth? = nil
}

struct Installapi_ASARequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: Auth_Auth {
    get {return _auth ?? Auth_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  var installID: String = String()

  var asaToken: String = String()

  /// marshaled json data
  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: Auth_Auth? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "installapi"

extension Installapi_DeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "install_id"),
    3: .same(proto: "idfa"),
    4: .same(proto: "idfv"),
    5: .standard(proto: "bundle_ver"),
    6: .same(proto: "locale"),
    7: .same(proto: "device"),
    8: .standard(proto: "os_ver"),
    9: .standard(proto: "receipt_url"),
    10: .standard(proto: "receipt_len"),
    11: .standard(proto: "doc_date"),
    12: .standard(proto: "build_date"),
    13: .same(proto: "currency"),
    14: .same(proto: "region"),
    15: .standard(proto: "sdk_init_date"),
  ]

  fileprivate class _StorageClass {
    var _auth: Auth_Auth? = nil
    var _installID: String = String()
    var _idfa: String = String()
    var _idfv: String = String()
    var _bundleVer: String = String()
    var _locale: String = String()
    var _device: String = String()
    var _osVer: String = String()
    var _receiptURL: String = String()
    var _receiptLen: String = String()
    var _docDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _buildDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _currency: String = String()
    var _region: String = String()
    var _sdkInitDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _auth = source._auth
      _installID = source._installID
      _idfa = source._idfa
      _idfv = source._idfv
      _bundleVer = source._bundleVer
      _locale = source._locale
      _device = source._device
      _osVer = source._osVer
      _receiptURL = source._receiptURL
      _receiptLen = source._receiptLen
      _docDate = source._docDate
      _buildDate = source._buildDate
      _currency = source._currency
      _region = source._region
      _sdkInitDate = source._sdkInitDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._auth) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._installID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._idfa) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._idfv) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._bundleVer) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._locale) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._device) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._osVer) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._receiptURL) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._receiptLen) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._docDate) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._buildDate) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._region) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._sdkInitDate) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._auth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._installID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._installID, fieldNumber: 2)
      }
      if !_storage._idfa.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idfa, fieldNumber: 3)
      }
      if !_storage._idfv.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idfv, fieldNumber: 4)
      }
      if !_storage._bundleVer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bundleVer, fieldNumber: 5)
      }
      if !_storage._locale.isEmpty {
        try visitor.visitSingularStringField(value: _storage._locale, fieldNumber: 6)
      }
      if !_storage._device.isEmpty {
        try visitor.visitSingularStringField(value: _storage._device, fieldNumber: 7)
      }
      if !_storage._osVer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._osVer, fieldNumber: 8)
      }
      if !_storage._receiptURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiptURL, fieldNumber: 9)
      }
      if !_storage._receiptLen.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiptLen, fieldNumber: 10)
      }
      if let v = _storage._docDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._buildDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 13)
      }
      if !_storage._region.isEmpty {
        try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 14)
      }
      if let v = _storage._sdkInitDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Installapi_DeviceRequest, rhs: Installapi_DeviceRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._auth != rhs_storage._auth {return false}
        if _storage._installID != rhs_storage._installID {return false}
        if _storage._idfa != rhs_storage._idfa {return false}
        if _storage._idfv != rhs_storage._idfv {return false}
        if _storage._bundleVer != rhs_storage._bundleVer {return false}
        if _storage._locale != rhs_storage._locale {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._osVer != rhs_storage._osVer {return false}
        if _storage._receiptURL != rhs_storage._receiptURL {return false}
        if _storage._receiptLen != rhs_storage._receiptLen {return false}
        if _storage._docDate != rhs_storage._docDate {return false}
        if _storage._buildDate != rhs_storage._buildDate {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._sdkInitDate != rhs_storage._sdkInitDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Installapi_AttribRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttribRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "install_id"),
    3: .same(proto: "broker"),
    4: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.installID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.broker) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.installID.isEmpty {
      try visitor.visitSingularStringField(value: self.installID, fieldNumber: 2)
    }
    if !self.broker.isEmpty {
      try visitor.visitSingularStringField(value: self.broker, fieldNumber: 3)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Installapi_AttribRequest, rhs: Installapi_AttribRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.installID != rhs.installID {return false}
    if lhs.broker != rhs.broker {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Installapi_TestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "install_id"),
    3: .same(proto: "name"),
    4: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.installID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.group) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.installID.isEmpty {
      try visitor.visitSingularStringField(value: self.installID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.group.isEmpty {
      try visitor.visitSingularStringField(value: self.group, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Installapi_TestRequest, rhs: Installapi_TestRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.installID != rhs.installID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.group != rhs.group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Installapi_EraseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EraseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "install_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.installID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.installID.isEmpty {
      try visitor.visitSingularStringField(value: self.installID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Installapi_EraseRequest, rhs: Installapi_EraseRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.installID != rhs.installID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Installapi_IDFARequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IDFARequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "install_id"),
    3: .same(proto: "idfa"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.installID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.idfa) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.installID.isEmpty {
      try visitor.visitSingularStringField(value: self.installID, fieldNumber: 2)
    }
    if !self.idfa.isEmpty {
      try visitor.visitSingularStringField(value: self.idfa, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Installapi_IDFARequest, rhs: Installapi_IDFARequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.installID != rhs.installID {return false}
    if lhs.idfa != rhs.idfa {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Installapi_ASARequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ASARequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "install_id"),
    3: .standard(proto: "asa_token"),
    4: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.installID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asaToken) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.installID.isEmpty {
      try visitor.visitSingularStringField(value: self.installID, fieldNumber: 2)
    }
    if !self.asaToken.isEmpty {
      try visitor.visitSingularStringField(value: self.asaToken, fieldNumber: 3)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Installapi_ASARequest, rhs: Installapi_ASARequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.installID != rhs.installID {return false}
    if lhs.asaToken != rhs.asaToken {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app/purchase/purchaseapi/api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Purchaseapi_TransactionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: Auth_Auth {
    get {return _auth ?? Auth_Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {self._auth = nil}

  /// random unique value, e.g. timestamp+rand(int64)
  var installID: String = String()

  /// array of transaction ids
  var transactions: [String] = []

  /// next 2 fields were added for a special idea but not used for now
  var docDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _docDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_docDate = newValue}
  }
  /// Returns true if `docDate` has been explicitly set.
  var hasDocDate: Bool {return self._docDate != nil}
  /// Clears the value of `docDate`. Subsequent reads from it will return its default value.
  mutating func clearDocDate() {self._docDate = nil}

  /// the same value sent in SetDevice
  var buildDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _buildDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_buildDate = newValue}
  }
  /// Returns true if `buildDate` has been explicitly set.
  var hasBuildDate: Bool {return self._buildDate != nil}
  /// Clears the value of `buildDate`. Subsequent reads from it will return its default value.
  mutating func clearBuildDate() {self._buildDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auth: Auth_Auth? = nil
  fileprivate var _docDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _buildDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Purchaseapi_ReceiptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var auth: Auth_Auth {
    get {return _storage._auth ?? Auth_Auth()}
    set {_uniqueStorage()._auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return _storage._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {_uniqueStorage()._auth = nil}

  /// random unique value, e.g. timestamp+rand(int64)
  var installID: String {
    get {return _storage._installID}
    set {_uniqueStorage()._installID = newValue}
  }

  var transactions: [String] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  var idfa: String {
    get {return _storage._idfa}
    set {_uniqueStorage()._idfa = newValue}
  }

  var idfv: String {
    get {return _storage._idfv}
    set {_uniqueStorage()._idfv = newValue}
  }

  /// tbd: it's needed for sandbox check
  var receiptURL: String {
    get {return _storage._receiptURL}
    set {_uniqueStorage()._receiptURL = newValue}
  }

  var receiptLen: String {
    get {return _storage._receiptLen}
    set {_uniqueStorage()._receiptLen = newValue}
  }

  var receipt: Data {
    get {return _storage._receipt}
    set {_uniqueStorage()._receipt = newValue}
  }

  /// startting from iOS13
  var storefront: String {
    get {return _storage._storefront}
    set {_uniqueStorage()._storefront = newValue}
  }

  /// code from priceLocale or Locale
  var region: String {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  /// code from priceLocale or Locale
  var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  /// the same value sent in SetDevice
  var docDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._docDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._docDate = newValue}
  }
  /// Returns true if `docDate` has been explicitly set.
  var hasDocDate: Bool {return _storage._docDate != nil}
  /// Clears the value of `docDate`. Subsequent reads from it will return its default value.
  mutating func clearDocDate() {_uniqueStorage()._docDate = nil}

  /// the same value sent in SetDevice
  var buildDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._buildDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._buildDate = newValue}
  }
  /// Returns true if `buildDate` has been explicitly set.
  var hasBuildDate: Bool {return _storage._buildDate != nil}
  /// Clears the value of `buildDate`. Subsequent reads from it will return its default value.
  mutating func clearBuildDate() {_uniqueStorage()._buildDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Purchaseapi_ReceiptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Purchaseapi_TransactionsRequest: @unchecked Sendable {}
extension Purchaseapi_ReceiptRequest: @unchecked Sendable {}
extension Purchaseapi_ReceiptResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "purchaseapi"

extension Purchaseapi_TransactionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "install_id"),
    3: .same(proto: "transactions"),
    4: .standard(proto: "doc_date"),
    5: .standard(proto: "build_date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.installID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.transactions) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._docDate) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._buildDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.installID.isEmpty {
      try visitor.visitSingularStringField(value: self.installID, fieldNumber: 2)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactions, fieldNumber: 3)
    }
    try { if let v = self._docDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._buildDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Purchaseapi_TransactionsRequest, rhs: Purchaseapi_TransactionsRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs.installID != rhs.installID {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs._docDate != rhs._docDate {return false}
    if lhs._buildDate != rhs._buildDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Purchaseapi_ReceiptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceiptRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "auth"),
    2: .standard(proto: "install_id"),
    3: .same(proto: "transactions"),
    5: .same(proto: "idfa"),
    6: .same(proto: "idfv"),
    7: .standard(proto: "receipt_url"),
    8: .standard(proto: "receipt_len"),
    9: .same(proto: "receipt"),
    10: .same(proto: "storefront"),
    11: .same(proto: "region"),
    12: .same(proto: "currency"),
    13: .standard(proto: "doc_date"),
    14: .standard(proto: "build_date"),
  ]

  fileprivate class _StorageClass {
    var _auth: Auth_Auth? = nil
    var _installID: String = String()
    var _transactions: [String] = []
    var _idfa: String = String()
    var _idfv: String = String()
    var _receiptURL: String = String()
    var _receiptLen: String = String()
    var _receipt: Data = Data()
    var _storefront: String = String()
    var _region: String = String()
    var _currency: String = String()
    var _docDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _buildDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _auth = source._auth
      _installID = source._installID
      _transactions = source._transactions
      _idfa = source._idfa
      _idfv = source._idfv
      _receiptURL = source._receiptURL
      _receiptLen = source._receiptLen
      _receipt = source._receipt
      _storefront = source._storefront
      _region = source._region
      _currency = source._currency
      _docDate = source._docDate
      _buildDate = source._buildDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._auth) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._installID) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._transactions) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._idfa) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._idfv) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._receiptURL) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._receiptLen) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._receipt) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._storefront) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._region) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._docDate) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._buildDate) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._auth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._installID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._installID, fieldNumber: 2)
      }
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._transactions, fieldNumber: 3)
      }
      if !_storage._idfa.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idfa, fieldNumber: 5)
      }
      if !_storage._idfv.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idfv, fieldNumber: 6)
      }
      if !_storage._receiptURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiptURL, fieldNumber: 7)
      }
      if !_storage._receiptLen.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiptLen, fieldNumber: 8)
      }
      if !_storage._receipt.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._receipt, fieldNumber: 9)
      }
      if !_storage._storefront.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storefront, fieldNumber: 10)
      }
      if !_storage._region.isEmpty {
        try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 11)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 12)
      }
      try { if let v = _storage._docDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._buildDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Purchaseapi_ReceiptRequest, rhs: Purchaseapi_ReceiptRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._auth != rhs_storage._auth {return false}
        if _storage._installID != rhs_storage._installID {return false}
        if _storage._transactions != rhs_storage._transactions {return false}
        if _storage._idfa != rhs_storage._idfa {return false}
        if _storage._idfv != rhs_storage._idfv {return false}
        if _storage._receiptURL != rhs_storage._receiptURL {return false}
        if _storage._receiptLen != rhs_storage._receiptLen {return false}
        if _storage._receipt != rhs_storage._receipt {return false}
        if _storage._storefront != rhs_storage._storefront {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._docDate != rhs_storage._docDate {return false}
        if _storage._buildDate != rhs_storage._buildDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Purchaseapi_ReceiptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceiptResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Purchaseapi_ReceiptResponse, rhs: Purchaseapi_ReceiptResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
